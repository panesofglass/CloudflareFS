#!/usr/bin/env dotnet fsi

// Post-processor to add discriminated unions for OpenAPI discriminator schemas
// This bridges the gap until Hawaii supports discriminator generation natively

open System
open System.IO
open System.Text.RegularExpressions

let sanitizeTypeName (name: string) =
    name.Replace("_", "").Replace("-", "").Replace(".", "")
    |> fun s -> if s.Length > 0 then Char.ToUpper(s.[0]).ToString() + s.Substring(1) else s

let generateDiscriminatedUnion (typeName: string) (cases: (string * string) list) =
    let header = sprintf "// Discriminated union (auto-generated by post-processor - Hawaii doesn't support discriminator schemas yet)"
    let typeDecl = sprintf "type %s =" typeName
    let unionCases =
        cases
        |> List.map (fun (caseName, schemaType) -> sprintf "    | %s of %s" caseName schemaType)
        |> String.concat "\n"

    sprintf "%s\n%s\n%s\n" header typeDecl unionCases

let getBindingKindTypes (typesContent: string) =
    let pattern = @"type (workersbindingkind[a-z0-9]+)\s*="
    Regex.Matches(typesContent, pattern)
    |> Seq.cast<Match>
    |> Seq.map (fun m -> m.Groups.[1].Value)
    |> Seq.filter (fun name -> not (name.EndsWith("Type")))
    |> Seq.toList

let insertDiscriminatedUnion (typesContent: string) (beforePattern: string) (duCode: string) =
    let pattern = Regex.Escape(beforePattern)
    Regex.Replace(typesContent, pattern, duCode + "\n" + beforePattern, RegexOptions.Multiline)

let processWorkersTypes (typesFilePath: string) =
    printfn "Processing: %s" typesFilePath

    if not (File.Exists typesFilePath) then
        printfn "Error: File not found: %s" typesFilePath
        exit 1

    let content = File.ReadAllText(typesFilePath)

    // Check if already processed
    if content.Contains("// Discriminated union (auto-generated by post-processor") then
        printfn "Already processed - discriminated union found"
        exit 0

    // Find all binding kind types
    let bindingTypes = getBindingKindTypes content

    if List.isEmpty bindingTypes then
        printfn "Warning: No binding kind types found"
        exit 0

    printfn "Found %d binding types" (List.length bindingTypes)

    // Generate discriminated union cases
    let cases =
        bindingTypes
        |> List.map (fun typeName ->
            // Convert workersbindingkindassets -> Assets
            let caseName =
                typeName.Replace("workersbindingkind", "")
                |> sanitizeTypeName
            (caseName, typeName))

    // Generate the discriminated union
    let duCode = generateDiscriminatedUnion "workersbindingitem" cases

    // Insert before the line: type workersbindings = list<workersbindingitem>
    let beforeLine = "type workersbindings = list<workersbindingitem>"

    if not (content.Contains(beforeLine)) then
        printfn "Error: Could not find insertion point: %s" beforeLine
        exit 1

    let updatedContent = insertDiscriminatedUnion content beforeLine duCode

    // Write back
    File.WriteAllText(typesFilePath, updatedContent)
    printfn "âœ“ Successfully added discriminated union for workersbindingitem"
    printfn "  Cases: %d" (List.length cases)

// Main
let args = fsi.CommandLineArgs |> Array.tail

if args.Length = 0 then
    printfn "Usage: dotnet fsi post-process-discriminators.fsx <path-to-Types.fs>"
    exit 1

let typesFile = args.[0]
processWorkersTypes typesFile
