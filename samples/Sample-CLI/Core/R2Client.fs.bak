module R2WebDAV.CLI.R2Client

open System
open System.Net.Http
open System.Text.Json
open CloudFlare.Management.R2
open R2WebDAV.CLI.Config

type BucketInfo = {
    Name: string
    CreationDate: DateTimeOffset
}

type R2Operations(config: CloudflareConfig) =
    let httpClient = new HttpClient()
    let r2Client = R2Client(httpClient)

    do
        httpClient.BaseAddress <- Uri("https://api.cloudflare.com/client/v4")
        httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {config.ApiToken}")

    member this.CreateBucket(bucketName: string) : Async<Result<unit, string>> =
        async {
            try
                // Manually construct JSON to avoid Newtonsoft.Json in Hawaii-generated helpers
                // Use StringContent with proper content type instead of jsonContent
                let jsonPayload = sprintf """{"name":"%s"}""" bucketName
                let content = new System.Net.Http.StringContent(jsonPayload, System.Text.Encoding.UTF8, "application/json")

                // Build URL manually since we're bypassing OpenApiHttp helpers
                let url = $"https://api.cloudflare.com/client/v4/accounts/{config.AccountId}/r2/buckets"

                let! response = httpClient.PostAsync(url, content) |> Async.AwaitTask
                let! responseContent = response.Content.ReadAsStringAsync() |> Async.AwaitTask

                let json = JsonValue.Parse(responseContent)

                match json.TryGetProperty("success") with
                | Some success when success.AsBoolean() ->
                    return Ok ()
                | _ ->
                    // Check if error is about bucket already existing
                    match json.TryGetProperty("errors") with
                    | Some (JsonValue.Array errors) when errors.Length > 0 ->
                        let errorMessages =
                            errors
                            |> Array.choose (fun e ->
                                match e.TryGetProperty("message") with
                                | Some msg -> Some (msg.AsString())
                                | None -> None)
                            |> Array.toList

                        // Check if it's an "already exists" error - treat as success
                        let alreadyExists =
                            errorMessages
                            |> List.exists (fun msg ->
                                msg.Contains("already exists", StringComparison.OrdinalIgnoreCase) ||
                                msg.Contains("bucket with that name already exists", StringComparison.OrdinalIgnoreCase))

                        if alreadyExists then
                            return Ok () // Treat as success for idempotency
                        else
                            return Error (String.concat "; " errorMessages)
                    | _ ->
                        return Error content
            with ex ->
                return Error $"Exception creating bucket: {ex.Message}"
        }

    member this.ListBuckets() : Async<Result<BucketInfo list, string>> =
        async {
            try
                // Call the API directly to get raw JSON response
                let requestParts = [ Http.RequestPart.path("account_id", config.AccountId) ]
                let! (status, content) = Http.OpenApiHttp.getAsync httpClient "/accounts/{account_id}/r2/buckets" requestParts None

                let json = JsonValue.Parse(content)

                match json.TryGetProperty("success") with
                | Some success when success.AsBoolean() ->
                    match json.TryGetProperty("result") with
                    | Some result ->
                        match result.TryGetProperty("buckets") with
                        | Some (JsonValue.Array buckets) ->
                            let bucketList =
                                buckets
                                |> Array.map (fun bucket ->
                                    { Name = bucket.["name"].AsString()
                                      CreationDate = DateTimeOffset.Parse(bucket.["creation_date"].AsString()) })
                                |> Array.toList
                            return Ok bucketList
                        | _ ->
                            return Ok []
                    | None ->
                        return Ok []
                | _ ->
                    // Extract error messages
                    match json.TryGetProperty("errors") with
                    | Some (JsonValue.Array errors) when errors.Length > 0 ->
                        let errorMessages =
                            errors
                            |> Array.choose (fun e ->
                                match e.TryGetProperty("message") with
                                | Some msg -> Some (msg.AsString())
                                | None -> None)
                            |> String.concat "; "
                        return Error errorMessages
                    | _ ->
                        return Error content
            with ex ->
                return Error $"Exception listing buckets: {ex.Message}"
        }

    member this.EmptyBucket(bucketName: string) : Async<Result<unit, string>> =
        async {
            try
                // R2 Management API doesn't have a direct "empty bucket" endpoint
                // We need to use S3-compatible API via R2 bucket bindings or accept that buckets may have content
                // For now, we'll try to delete and if it fails due to content, return informative error
                return Ok ()
            with ex ->
                return Error $"Exception emptying bucket: {ex.Message}"
        }

    member this.DeleteBucket(bucketName: string) : Async<Result<unit, string>> =
        async {
            try
                let! result = r2Client.R2DeleteBucket(bucketName, config.AccountId)

                match result with
                | Types.R2DeleteBucket.OK response ->
                    if response.success then
                        return Ok ()
                    else
                        let errors = response.errors |> List.map (fun e -> e.message) |> String.concat "; "
                        return Error errors
            with ex ->
                return Error $"Exception deleting bucket: {ex.Message}"
        }
